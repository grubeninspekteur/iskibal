= AsciiDoc plus Iskara

This document describes how Iskara rule sources can be embedded in AsciiDoc.
It focusses on the externalization of rule metadata such as imports, facts, outputs, globals and decision tables so they can be maintained using standard AsciiDoc structures.

See the <<Iskara_Language_Reference.adoc#,Iskara Language Reference>> for the syntax of the rule language itself.

== Organizing rule sources

AsciiDoc documents may contain multiple rule fragments.
Listing blocks annotated with the `rule` role become rule sections.
Rules can be freely mixed with other sections and then collected by a pre-processor before compilation.

The rule header can be specified in the source block, but for nicer formatting, there is also the `<rule ID>: <description>` shorthand in captions:

.RULE-001: Insufficient balance
[source,iskara,.rule]
----
when:
    (Balance - Order.items.price sum) < 0
then:
    error: "Insufficient balance for purchase"
----

Data required by the rules can be defined using structural blocks that are independent of the rule listings.
This allows data to be re-used, included from other files and even generated.

== Imports

Imports map identifiers used inside the rules to classes of the target language.
They are written as a definition list with the role `imports`:

[.imports]
====
Vehicle:: org.acme.Vehicle
Passenger:: org.acme.PersonImpl
====

Multiple import blocks are merged by the parser, allowing imports to be grouped and reused in different documents.

== Facts

Facts provide the named objects that are available to all rules.
They can be declared either as a definition list or as a three column table with the role `facts`.
The columns are *Fact name*, *Type* and an optional *Description*.

[cols="1,1,3",.facts]
|===
| Fact name | Type | Description

| vehicleCrossingTheBorder | Vehicle | The vehicle that arrived at the border checkpoint.
| prompt | Prompt | Allows to ask the user for input.
|===

== Outputs

Outputs are similar to facts but are produced by the rule execution.
They are written as a four column table with the role `outputs`.
The columns are *Output name*, *Type*, *Initial value* and an optional *Description*.

[cols="1,1,1,3",.outputs]
|===
| Output name | Type | Initial value | Description

| rejectionReasons | String[] | [] | List of reasons the border crossing was not allowed.
|===

== Globals

Additional global state can be declared using tables with the role `globals`.
The column order matches that of the facts table.

== Data tables

AsciiDoc tables can hold external data referenced by rules.
The table's ID is given by the AsciiDoc block ID.

[#vehicle-weight-limits,.data-table]
|===
| Type  | Maximum Weight

| Car   | 1.5t
| Lorry | 5t
|===

== Decision tables

Decision tables can be modeled with regular AsciiDoc tables carrying the `decision-table` role.
The table caption becomes the human readable title, while the table ID is used as the rule identifier.
The first two header rows define the structure and expressions for each condition or consequence column.
Subsequent rows describe individual rules; only cells with content participate in a rule.

Aliases referenced in the header using `#alias` may be defined after the table in a definition list with the role `aliases`.

The decision table from the language reference can be represented as follows:

[#BEST_OFFERS,.decision-table]
.Show best offers
|===
| ID 2+| WHEN                      2+| THEN

| h| #`has birthday` h| Customer.age h| Discount add: "birthday" withPercent: h| #offerCar
| BIRTHDAY_DISCOUNT | * | | 15 |
| BD_CAR_OFFER | * | >= 18 | | "blue"
|===

[.aliases,for="BEST_OFFERS"]
has birthday::
+
[source,iskara]
----
Customer.dateOfBirth = Today
----
offerCar::
+
[source,iskara]
----
let color := param
messages add: $"Did you know you can get a birthday paint in ${color} for your car?"
----

Identifiers do not need to be quoted in the definition list.

== Includes and modularization

Because all of these structures are plain AsciiDoc, they can be stored in separate files and brought together with the standard `include::` directive.
This enables the creation of shared libraries of tables, globals and decision tables that can be combined to form larger rule bases.

